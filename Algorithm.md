# 基础
## 一、排序

### 1.冒泡排序

相邻的两位依次做比较交换，从右至左依次确定数据

### 2.选择排序

遍历位依次与未确定位的极值做比较交换，从左至右依次确定数据

### 3.插入排序

遍历位依次与已确定位做比较交换，从左至右依次确定数据，时间复杂度受数据状况（逆序对的数量）影响

### 4.希尔排序

插入排序的优化，通过改变增量的方式让每次交换由原本的相邻交换减少1对逆序对变为增量交换减少多于1对逆序对，例：[5,4,3,2,1]，增量为1，交换减少1对，增量为2，减少2对

### 5.归并排序

通过递归不断二分，左右分别有序，合并后整体有序

可用于解决小和问题和逆序对问题

### 6.快速排序

1.0版本：取末位数作为基准值（pivot），将数组分区（partition）为<=区和>区，<=区末尾为基准值，递归两个区域

2.0版本：取末位数作为基准值（pivot），将数组分区（partition）为<区、=区、>区，递归两端区域

3.0版本：随机取一个数与末位数交换，作为基准值（pivot），将数组分区（partition）为<区、=区、>区，递归两端区域

可用于解决topk问题

### 7.堆排序

堆：数组实现的完全二叉树（从上往下，从左往右依次填节点的二叉树），每颗子树的极值都在头节点

由数组构成，根节点索引为n，则left为2n+1，right为2n+2

上浮siftup：循环和父节点比较与交换
下沉siftdown：循环和子节点中更大/小者比较与交换
堆化heapify：从数组末尾的父节点开始，递减索引做siftdown
add：加在数组末尾，个数count++，siftup
poll：数组头尾交换，个数count--，siftdown

可用于解决topk问题、近似有序数组（每个元素排序调整的距离不超过k）的排序

### 8.桶排序

1）计数排序：数组的索引映射要比较的值，值为个数

2）基数排序：每个数从个位到最高位依次排序

> 不基于比较的排序

## 二、链表

常用技巧
1）快慢指针找中点
2）快慢指针找入环节点：快慢指针相交后，快指针指向头节点并步长改为1，再次相遇即为入环点

## 三、二叉查找树BST

对于每颗子树的值都符合左子树所有值<头<右子树所有值，中序遍历为升序排列

## 四、前缀树Trim

## 五、动态规划

递归==》记忆化递归==》严格表==》严格表优化

- 递归
- 记忆化递归
- 严格表

---

# 进阶
## 一、KMP

O(n+m)时间复杂度，n为主串长度，m为模式串长度，利用已匹配字符信息加速匹配字符串

1）建立m的next数组，next[i]存的是[0...i-1]区域部分匹配值（前缀与后缀的最长共有元素长度），用于比较字符不相同时加速，i=next[i]

2）n和m通过i1，i2遍历比较:
- 字符相同，i1++，i2++
- 字符不相同
    - i2==0则i1++
    - i2 = next[i2]

## 二、Manacher

O(N)时间复杂度求最长回文字符串

1）在原字符串s首尾和字符之间添加字符（如#，字符无限制），生成新字符串m

2）建立p数组，p[i]为以m[i]为中心构成的最长回文串半径，R为最大回文有边界，C中心随R伴生

3）在...L...i'...C...i...R...中p[i]存在四种情况：
- i>R，p[i]=1并遍历尝试，更新R、C
- i<=R：
    - p[i']<L，p[i]=p[i']
    - p[i']>L，p[i]=R-i+1，证明：在...xL...i'...L'y...C...mR'...i...Rn...中，因x=y=m，则m≠n
    - p[i']=L，p[i]=p[i']并继续遍历尝试，更新R、C
> 代码层面优化：R设为右边界+1的位置，i<=R的三种情况半径赋值先合并处理，再统一尝试外扩

## 三、哈希表

