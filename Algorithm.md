## 一、排序

### 1.冒泡排序

相邻的两位依次做比较交换，从右至左依次确定数据

### 2.选择排序

遍历位依次与未确定位的极值做比较交换，从左至右依次确定数据

### 3.插入排序

遍历位依次与已确定位做比较交换，从左至右依次确定数据，时间复杂度受数据状况（逆序对的数量）影响

### 4.希尔排序

插入排序的优化，通过改变增量的方式让每次交换由原本的相邻交换减少1对逆序对变为增量交换减少多于1对逆序对，例：[5,4,3,2,1]，增量为1，交换减少1对，增量为2，减少2对

### 5.归并排序

通过递归不断二分，左右分别有序，合并后整体有序

可用于解决小和问题和逆序对问题

### 6.快速排序

1.0版本：取末位数作为基准值（pivot），将数组分区（partition）为<=区和>区，<=区末尾为基准值，递归两个区域

2.0版本：取末位数作为基准值（pivot），将数组分区（partition）为<区、=区、>区，递归两端区域

3.0版本：随机取一个数与末位数交换，作为基准值（pivot），将数组分区（partition）为<区、=区、>区，递归两端区域

可用于解决topk问题

### 7.堆排序

堆：数组实现的完全二叉树（从上往下，从左往右依次填节点的二叉树），每颗子树的极值都在头节点

由数组构成，根节点索引为n，则left为2n+1，right为2n+2

上浮siftup：循环和父节点比较与交换
下沉siftdown：循环和子节点中更大/小者比较与交换
堆化heapify：从数组末尾的父节点开始，递减索引做siftdown
add：加在数组末尾，个数count++，siftup
poll：数组头尾交换，个数count--，siftdown

可用于解决topk问题、近似有序数组（每个元素排序调整的距离不超过k）的排序

### 8.桶排序

1）计数排序：数组的索引映射要比较的值，值为个数

2）基数排序：每个数从个位到最高位依次排序

> 不基于比较的排序

## 二、符号表

### 1.链表

### 2.二叉查找树BST

每颗子树的值都符合left<=头<=right

### 3.红黑树

### 4.前缀树Trim

