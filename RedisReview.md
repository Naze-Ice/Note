## 线程模型

redis内部使用文件事件处理器，这个**文件事件处理器是单线程**的，所以才说redis是单线程的模型。它采用IO多路复用机制监听多个socket，根据socket上的事件选择相应的事件处理器去处理

文件事件处理器的结构

- 

## 持久化

- RDB：快照，一次全量备份，数据紧凑的二进制文件
  - save：保存快照，同步，会阻塞客户端指令
  - bgsave：后台保存快照，异步非阻塞，通过fork()函数开启**子进程**执行
  - save配置：默认开启

```
save 900 1		#900s内至少对数据库进行了1次修改
save 300 10
save 60 10000
```

> 原理：调用fork()函数后会开启一个子进程，与父进程共享数据，子进程对数据结构进行遍历读取并序列化写入磁盘，父进程需要持续服务客户端请求，当需要修改数据时，会采用操作系统的COW（copy on write）机制，将被共享的数据段（由操作系统的页面组成）页面复制一份，并在复制的页面进行修改

- AOF（append-only file）：日志，连续的增量备份，顺序记录对内存的修改指令
  - 原理
    - 命令追加：执行写命令，并追加到缓冲区的末尾
    - 文件写入与同步：根据配置appendfsync的值判断是否将缓冲区的内容写入和保存到AOF文件
  - **AOF重写**：长期运行使AOF日志越来越大，导致重放时间变长，需要进行AOF重写，对应指令BGREWRITEAOF指令。
    - 开辟一个子进程对内存进行遍历转换成一系列的Redis操作指令，并写入新的AOF文件
    - 同时此期间父进程执行写操作时会将指令记录到重写缓冲区
    - 子进程写入完成后会将重写缓冲区的指令追加到新AOF文件，最终替换AOF文件

```
appendonly yes  #开启aof
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #（默认值）每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
```

**服务器载入文件时的启动流程**

![image-20200413133603373](images/image-20200413133603373-1586756169936.png)

**Redis 4.0 对于持久化机制的优化**

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。如果把混合持久化打开，**AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头**

- 优点：快速加载同时避免丢失过多的数据
- 缺点：AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差

## 过期数据删除策略

数据删除策略目标是在内存占用和CPU占用之间寻找平衡

- 定时删除（处理器性能换取存储空间）：创建一个定时器，当key设置有过期时间且已经过期则立即删除键
  - 优点：节约内存
  - 缺点：CPU压力大，无论CPU负载量多高都会占用CPU，会影响redis服务器的响应速度和吞吐量
- 惰性删除（存储空间换取处理器性能）：数据过期时不处理，访问该数据时，如果发现过期则删除，返回不存在
  - 优点：节约CPU性能
  - 缺点内存压力大
- 定期删除：

## 分布式锁

Redis做分布式锁的问题

- 死锁：如果解锁时删除键失败，将陷入死锁，所以锁必须设置过期时间，且设置锁和过期时间的操作必须具有原子性

  > Redis2.8以后加入了set的参数设置nx和ex，相当于setnx和expire组合在一起的原子操作

- 超时：锁过期后

  > 可通过给value设置随机值，删除先判断valueLUA脚本

- 可重入性：