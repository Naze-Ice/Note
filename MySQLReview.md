# 一、事务

## ACID

- 原子性（Atomicity）

> 回滚可以用回滚日志（Undo Log）实现，回滚日志记录着事务所执行的修改操作，反向执行达到回滚效果

- 一致性（Consistency）
- 隔离性（Isolation）
- 持久性（Durability）

> 系统崩溃时可以用重做日志（Redo Log）进行恢复，实现持久性，与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改

ACID关系：

![](images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231303433373032332e706e67.png)

AUTOCOMMIT：

MySQL默认采用自动提交模式。如果不显示使用`START TRANSACTION`来开始一个事务，每个查询都会被当作一个事务自动提交

## 并发一致性问题

- 丢失修改

![](images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313734343234342e706e67.png)

- 脏读

![](images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313932303336382e706e67.png)

- 不可重复读

![](images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323130323031302e706e67.png)

- 幻读

![](images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323130323031302e706e67.png)

## 隔离级别

|          | 脏读    | 不可重复读 | 幻读    |
| -------- | ------- | ---------- | ------- |
| 未提交读 | &radic; | &radic;    | &radic; |
| 已提交读 | &times; | &radic;    | &radic; |
| 可重复读 | &times; | &times;    | &radic; |
| 可串行化 | &times; | &times;    | &times; |

**丢失修改**：

- 任何隔离级别下，都不会导致数据库理论意义下的丢失修改，任何隔离级别对行更新操作时都会对行或其他粒度的对象加锁

- 生产应用中可能出现逻辑意义的丢失修改，比如：

  1）事务T1查询一行数据，放入本地内存并显示给用户U1

  2）事务T2也查询该行数据，并显示给用户U2

  3）U1修改该行数据，更新数据库并提交

  4）U2修改该行数据，更新数据库并提交

  此时U1修改丢失，银行转账也存在这种问题，可通过U盾解决

  **数据库层面解决**，两种方式：

  - 悲观锁

  将操作变为串行化，在步骤1和步骤2都加上X锁
  
  ```mysql
begin;
  select * from account where id = 1 for update;
  update account set balance=150 where id =1;
  commit;
  ```
  
  > 两个事务都直接update也不会存在丢失修改，但现实场景有可能先查数据做业务判断，再修改
  
  - 乐观锁
  
  

## MVVC

多版本并发控制，

# 二.锁

![](images/164c6d7ae44d8ac6.png)

## 锁类型与锁粒度

### 1.表锁

- 

### 2.行锁

- 共享锁（Shared）：S锁/读锁，允许事务读一行数据
- 互斥锁（Exclusive）：X锁/写锁，允许事务删除或更新一条数据

> 读写锁间都是仅读读兼容

### 3.意向锁

使用意向锁（Intention Locks）是为了支持不同粒度的加锁操作，该意向锁为**表级锁**

- 意向共享锁：IS
- 意向互斥锁：IX

## 封锁协议

### 1.三级封锁协议

- 一级封锁协议：事务T要修改数据A时必须加X锁，直到T结束释放，可以解决丢失修改问题
- 二级封锁协议：一级的基础，要求读数据A时必须加S锁，**读取完就释放**，可以解决脏读
- 三级封锁协议：一级的基础，要求读取数据A时必须加S锁，**直到事务结束才释放**，可以解决不可重复读

### 2.两段锁协议

事务执行过程，随时可以执行锁定，事务结束（commit/rollback）后锁在同一时刻释放。可以保证可串行化调度

```
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```

> 可串行化调度：通过并发控制使得并发执行的事务结果和串行执行的结果一致

## 隐式与显示锁定

MySQL的InnoDB**采用两阶段锁协议**

- 隐式锁定：InnoDB根据隔离级别在需要加锁的时候自动加锁

- 显示锁定：InnoDB支持

  - ```mysql
    SELECT ... LOCK IN SHARE MODE -- S锁
    ```

  - ```mysql
    SELECT ... FOR UPDATE -- X锁
    ```

## 一致性非锁定读

InnoDB通过行多版本控制的方式读取当前执行时间数据库中行的数据，即如果当前读取的行被X锁定，这时读取操作不会阻塞等待X锁的释放，会直接读取行的快照数据

### MVCC

InnoDB的已提交读和可重复读隔离级别下均使用一致性非锁定读，两种隔离级别读取不同的版本快照数据，称为多版本并发控制

- 已提交读：读取行最新的版本快照数据
- 可重复读：读取事务开始时的版本快照数据

#### 实现

MVVC通过增加版本号和Undo日志实现

**版本号**

- 系统版本号SYS_ID：递增数字，每开启一个事务就自动递增
- 事务版本号TRX_ID：事务开始时的系统版本号

**Undo日志**

快照存储在Undo日志中，通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来

```mysql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

MySQL的AUTOCOMMIT机制，这里没有显示开启事务，所以是三个事务，快照中除了记录事务版本号操作外还记录了DEL字段，DELECT时设置为1

![](images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383136343830383231372e706e67.png)

**ReadView**

MVCC维护了一个ReadView结构，包含了当前系统未提交的事务列表TRX_IDS，进行SELECT时

- TRX_ID < TRX_ID_MIN，该快照在当前所有未提交事务之前进行更改的，可以使用。
- TRX_ID > TRX_ID_MAX，该快照是在事务启动之后被更改的，不可使用。
- TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：
  - 提交读：该快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
  - 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。

## 一致性锁定读



# 二、索引

## B+Tree原理

### 1.数据结构：

B Tree（Balance Tree）：平衡树，是一颗查找树，并且所有叶子节点位于同一层

B+ Tree：基于B Tree和叶子节点顺序访问（从左到右非递增排列）指针进行实现，具有B Tree的平衡性，并且通过顺序访问指针来提高范围查询的性能

MySQL中：

![](images/164c6d7a53a7920b.png)

![](images/164c6d7a53b78847.png)

- 各数据页组成一个双向链表
- 每个数据页中的记录组成一个单向链表

### 2.操作

![](images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33333537363834392d393237352d343762622d616461372d3864656435663565376337332e706e67.png)

进行查找时，首先根据根节点递归二分查找，直到查到叶子节点，然后在叶子节点二分查找，找到key对应的data

MySQL中：

![](images/164c6d7a5663f62b.png)

> record_type：0：普通用户记录（用户自定义的列+InnoDB的隐藏列），1：目录项记录（主键值+页码），2：最小记录，3：最大记录

插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

## 哈希索引

![](images/164c6d7a55fd52b3.png)

本质是把key换算成哈希值，根据哈希值定位，缺陷：

- 无法排序
- 不支持最左匹配原则
- hash碰撞
- 不支持范围查询

> InnoDB中是自适应哈希索引，即由引擎自动优化创建

## 索引优化

### 1.独立的列

索引列不能是表达式的一部分，也不能是函数的参数，反例：

```mysql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

### 2.多列索引

需要多个列作为查询条件时使用多列索引比多个单列索引性能更高

### 3.前缀索引和索引选择性

选择性最强的索引放在前面

> 选择性：不重复的索引值个数和记录总数的比值，公式count(distinct col)/count(*)，选择性越高，区分度越高，查询效率越高

对于BLOB、TEXT和VARCHAR类型的列，必须使用前缀索引，如`value%`，前缀长度由索引选择性确定，例子：

```mysql
mysql> select 1.0*count(distinct name)/count(*) from test;
+-------------------------------------------+
| 1.0*count(distinct name)/count(*) |
+-------------------------------------------+
|                                   1.00000 |
+-------------------------------------------+
1 row in set (0.00 sec)

mysql> select 1.0*count(distinct left(name,1))/count(*) from test;
+-------------------------------------------+
| 1.0*count(distinct left(name,1))/count(*) |
+-------------------------------------------+
|                                   0.75000 |
+-------------------------------------------+
1 row in set (0.00 sec)

mysql> select 1.0*count(distinct left(name,2))/count(*) from test;
+-------------------------------------------+
| 1.0*count(distinct left(name,2))/count(*) |
+-------------------------------------------+
|                                   0.75000 |
+-------------------------------------------+
1 row in set (0.00 sec)

mysql> select 1.0*count(distinct left(name,3))/count(*) from test;
+-------------------------------------------+
| 1.0*count(distinct left(name,3))/count(*) |
+-------------------------------------------+
|                                   1.00000 |
+-------------------------------------------+
1 row in set (0.00 sec)
```

创建索引：

```mysql
mysql> alter table test add key(name(3));
Query OK, 4 rows affected (0.15 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

### 5.覆盖索引

索引包含所有需要查询的字段

# 3.存储引擎

# 

# 5.SQL

